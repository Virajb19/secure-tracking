import { Injectable, ConflictException, NotFoundException } from '@nestjs/common';
import { User, UserRole, Gender } from '@prisma/client';
import { PrismaService } from '../prisma';
import { CreateUserDto } from './dto/create-user.dto';
import { AuditLogsService, AuditAction } from '../audit-logs/audit-logs.service';
import { NotificationsService } from '../notifications/notifications.service';
import * as bcrypt from 'bcrypt';

/**
 * Registration data interface.
 */
export interface RegisterUserData {
    name: string;
    email: string;
    password: string; // Already hashed
    phone: string;
    role: UserRole;
    gender: Gender;
    profile_image_url?: string;
    is_active: boolean;
}

/**
 * Users Service.
 * Handles all user-related business logic.
 * All sensitive operations are logged to audit_logs.
 */
@Injectable()
export class UsersService {
    constructor(
        private readonly db: PrismaService,
        private readonly auditLogsService: AuditLogsService,
        private readonly notificationsService: NotificationsService,
    ) { }

    /**
     * Create a new user.
     * Phone must be unique across all users.
     * 
     * @param createUserDto - User creation data
     * @param creatorId - ID of the admin creating the user
     * @param ipAddress - IP address of the request
     * @returns Created user
     * @throws ConflictException if phone already exists
     */
    async create(
        createUserDto: CreateUserDto,
        creatorId: string,
        ipAddress: string | null,
    ): Promise<User> {
        // Check if phone already exists
        const existingUser = await this.db.user.findUnique({
            where: { phone: createUserDto.phone },
        });

        if (existingUser) {
            throw new ConflictException('User with this phone number already exists');
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(createUserDto.password, 10);

        // Create user - created_at is auto-generated by Prisma
        const savedUser = await this.db.user.create({
            data: {
                name: createUserDto.name,
                phone: createUserDto.phone,
                password: hashedPassword,
                role: createUserDto.role as UserRole,
                is_active: createUserDto.is_active ?? true,
                device_id: null, // Device ID is bound on first login
            },
        });

        // Log to audit trail
        await this.auditLogsService.log(
            AuditAction.USER_CREATED,
            'User',
            savedUser.id,
            creatorId,
            ipAddress,
        );

        return savedUser;
    }

    /**
     * Find all users.
     * Used by admin to list all users.
     * Includes faculty and related data for display.
     */
    async findAll(): Promise<User[]> {
        return this.db.user.findMany({
            include: {
                faculty: {
                    include: {
                        school: {
                            include: {
                                district: true,
                            },
                        },
                        teaching_assignments: true,
                    },
                },
            },
            orderBy: { created_at: 'desc' },
        });
    }

    /**
     * Find a user by ID.
     * 
     * @param id - User UUID
     * @throws NotFoundException if user not found
     */
    async findById(id: string): Promise<User> {
        const user = await this.db.user.findUnique({ where: { id } });

        if (!user) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }

        return user;
    }

    /**
     * Find a user by phone number.
     * Used for authentication.
     * 
     * @param phone - User phone number
     * @returns User or null if not found
     */
    async findByPhone(phone: string): Promise<User | null> {
        return this.db.user.findUnique({ where: { phone } });
    }

    /**
     * Find a user by email.
     * Used for admin authentication.
     * 
     * @param email - User email
     * @returns User or null if not found
     */
    async findByEmail(email: string): Promise<User | null> {
        return this.db.user.findUnique({ where: { email } });
    }

    /**
     * Register a new user (self-registration from mobile app).
     * 
     * SECURITY NOTES:
     * - Only for non-admin roles
     * - User is created as inactive (requires admin approval)
     * - Password should already be hashed
     * 
     * @param data - Registration data
     * @param ipAddress - Client IP for logging
     * @returns Created user
     */
    async registerUser(data: RegisterUserData, ipAddress: string | null): Promise<User> {
        const user = await this.db.user.create({
            data: {
                name: data.name,
                email: data.email,
                password: data.password,
                phone: data.phone,
                role: data.role,
                gender: data.gender,
                profile_image_url: data.profile_image_url,
                is_active: data.is_active,
                device_id: null,
            },
        });

        return user;
    }

    /**
     * Update user's device_id.
     * Used when DELIVERY user logs in for the first time.
     * 
     * SECURITY: Once device_id is set, it cannot be changed.
     * 
     * @param userId - User ID
     * @param deviceId - Device ID to bind
     * @param ipAddress - IP address of the request
     */
    async bindDeviceId(
        userId: string,
        deviceId: string,
        ipAddress: string | null,
    ): Promise<User> {
        // Update device_id (only if not already set - checked in auth service)
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { device_id: deviceId },
        });

        // Log device binding
        await this.auditLogsService.log(
            AuditAction.DEVICE_ID_BOUND,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Deactivate a user.
     * Prevents the user from logging in.
     * 
     * @param userId - User ID to deactivate
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async deactivate(
        userId: string,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { is_active: false },
        });

        await this.auditLogsService.log(
            AuditAction.USER_DEACTIVATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Toggle user active status.
     * Used by admin to activate or deactivate users.
     * 
     * @param userId - User ID to toggle
     * @param isActive - New active status
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async toggleActiveStatus(
        userId: string,
        isActive: boolean,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const user = await this.findById(userId);
        
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { is_active: isActive },
        });

        await this.auditLogsService.log(
            isActive ? AuditAction.USER_ACTIVATED : AuditAction.USER_DEACTIVATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        // Send notification to user
        if (isActive) {
            await this.notificationsService.notifyAccountActivated(userId);
        } else {
            await this.notificationsService.notifyAccountDeactivated(userId);
        }

        return updatedUser;
    }

    /**
     * Update personal details (name, phone, gender).
     * Used by mobile app users to update their basic info.
     * 
     * @param userId - User ID
     * @param data - Personal details to update
     * @param ipAddress - IP address of the request
     */
    async updatePersonalDetails(
        userId: string,
        data: { name?: string; phone?: string; gender?: Gender },
        ipAddress: string | null,
    ): Promise<User> {
        // Check if phone is being changed and if it's already taken
        if (data.phone) {
            const existingUser = await this.db.user.findUnique({
                where: { phone: data.phone },
            });
            if (existingUser && existingUser.id !== userId) {
                throw new ConflictException('Phone number already in use');
            }
        }

        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: {
                ...(data.name && { name: data.name }),
                ...(data.phone && { phone: data.phone }),
                ...(data.gender && { gender: data.gender }),
            },
        });

        await this.auditLogsService.log(
            AuditAction.USER_UPDATED,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }
}
