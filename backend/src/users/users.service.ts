import { Injectable, ConflictException, NotFoundException } from '@nestjs/common';
import { User, UserRole, Gender } from '@prisma/client';
import { PrismaService } from '../prisma';
import { CreateUserDto } from './dto/create-user.dto';
import { AuditLogsService, AuditAction } from '../audit-logs/audit-logs.service';
import { NotificationsService, NotificationType } from '../notifications/notifications.service';
import * as bcrypt from 'bcrypt';

/**
 * Registration data interface.
 */
export interface RegisterUserData {
    name: string;
    email: string;
    password: string; // Already hashed
    phone: string;
    role: UserRole;
    gender: Gender;
    profile_image_url?: string;
    is_active: boolean;
}

/**
 * Users Service.
 * Handles all user-related business logic.
 * All sensitive operations are logged to audit_logs.
 */
@Injectable()
export class UsersService {
    constructor(
        private readonly db: PrismaService,
        private readonly auditLogsService: AuditLogsService,
        private readonly notificationsService: NotificationsService,
    ) { }

    /**
     * Create a new user.
     * Phone must be unique across all users.
     * 
     * @param createUserDto - User creation data
     * @param creatorId - ID of the admin creating the user
     * @param ipAddress - IP address of the request
     * @returns Created user
     * @throws ConflictException if phone already exists
     */
    async create(
        createUserDto: CreateUserDto,
        creatorId: string,
        ipAddress: string | null,
    ): Promise<User> {
        // Check if phone already exists
        const existingUser = await this.db.user.findUnique({
            where: { phone: createUserDto.phone },
        });

        if (existingUser) {
            throw new ConflictException('User with this phone number already exists');
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(createUserDto.password, 10);

        // Create user - created_at is auto-generated by Prisma
        const savedUser = await this.db.user.create({
            data: {
                name: createUserDto.name,
                phone: createUserDto.phone,
                password: hashedPassword,
                role: createUserDto.role as UserRole,
                is_active: createUserDto.is_active ?? true,
                device_id: null, // Device ID is bound on first login
            },
        });

        // Log to audit trail
        await this.auditLogsService.log(
            AuditAction.USER_CREATED,
            'User',
            savedUser.id,
            creatorId,
            ipAddress,
        );

        return savedUser;
    }

    /**
     * Find all users.
     * Used by admin to list all users.
     * Includes faculty and related data for display.
     */
    async findAll(): Promise<User[]> {
        return this.db.user.findMany({
            include: {
                faculty: {
                    include: {
                        school: {
                            include: {
                                district: true,
                            },
                        },
                        teaching_assignments: true,
                    },
                },
            },
            orderBy: { created_at: 'desc' },
        });
    }

    /**
     * Find users with pagination and filters.
     * Server-side pagination - only fetches data for the requested page.
     */
    async findAllPaginated(params: {
        page: number;
        limit: number;
        role?: string;
        district_id?: string;
        school_id?: string;
        class_level?: number;
        class_levels?: number[]; // Array of class levels (for SUBJECT_COORDINATOR filtering)
        subject?: string;
        search?: string;
        is_active?: boolean;
        approval_status?: string;
        exclude_roles?: string[];
    }): Promise<{
        data: User[];
        total: number;
        page: number;
        limit: number;
        totalPages: number;
    }> {
        const { page, limit, role, district_id, school_id, class_level, class_levels, subject, search, is_active, approval_status, exclude_roles } = params;

        // Build the list of roles to exclude (always exclude ADMIN and SUPER_ADMIN)
        const rolesToExclude: UserRole[] = [UserRole.ADMIN, UserRole.SUPER_ADMIN];
        if (exclude_roles && exclude_roles.length > 0) {
            exclude_roles.forEach(r => {
                if (Object.values(UserRole).includes(r as UserRole)) {
                    rolesToExclude.push(r as UserRole);
                }
            });
        }

        // Build where clause
        const where: any = {
            // Exclude specified roles
            role: {
                notIn: rolesToExclude,
            },
        };

        // Role filter
        if (role) {
            where.role = role as UserRole;
        }

        // Active status filter
        if (is_active !== undefined) {
            where.is_active = is_active;
        }

        // Approval status filter (through faculty)
        if (approval_status) {
            where.faculty = {
                ...where.faculty,
                approval_status: approval_status,
            };
        }

        // Search filter (name, phone, email)
        if (search) {
            where.OR = [
                { name: { contains: search, mode: 'insensitive' } },
                { phone: { contains: search, mode: 'insensitive' } },
                { email: { contains: search, mode: 'insensitive' } },
            ];
        }

        // District filter (through faculty -> school -> district)
        if (district_id) {
            where.faculty = {
                ...where.faculty,
                school: {
                    district_id,
                },
            };
        }

        // School filter
        if (school_id) {
            where.faculty = {
                ...where.faculty,
                school_id,
            };
        }

        // Class level filter (through teaching_assignments)
        if (class_level) {
            where.faculty = {
                ...where.faculty,
                teaching_assignments: {
                    some: {
                        class_level,
                    },
                },
            };
        }

        // Class levels array filter (for SUBJECT_COORDINATOR - filters by multiple class levels)
        if (class_levels && class_levels.length > 0) {
            where.faculty = {
                ...where.faculty,
                teaching_assignments: {
                    some: {
                        class_level: { in: class_levels },
                    },
                },
            };
        }

        // Subject filter (through teaching_assignments)
        if (subject) {
            where.faculty = {
                ...where.faculty,
                teaching_assignments: {
                    some: {
                        subject: { equals: subject, mode: 'insensitive' },
                    },
                },
            };
        }

        // Get total count
        const total = await this.db.user.count({ where });

        // Calculate offset
        const skip = (page - 1) * limit;

        // Fetch paginated data
        const data = await this.db.user.findMany({
            where,
            include: {
                faculty: {
                    include: {
                        school: {
                            include: {
                                district: true,
                            },
                        },
                        teaching_assignments: true,
                    },
                },
            },
            orderBy: [
                { is_active: 'desc' }, // Active users first
                { created_at: 'desc' },
            ],
            skip,
            take: limit,
        });

        return {
            data,
            total,
            page,
            limit,
            totalPages: Math.ceil(total / limit),
        };
    }

    /**
     * Find a user by ID.
     * 
     * @param id - User UUID
     * @throws NotFoundException if user not found
     */
    async findById(id: string): Promise<User> {
        const user = await this.db.user.findUnique({ where: { id } });

        if (!user) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }

        return user;
    }

    /**
     * Get user's teaching assignments.
     * Returns class levels and subjects the user teaches.
     * 
     * @param userId - User ID
     * @returns Teaching assignments array
     */
    async getTeachingAssignments(userId: string): Promise<{ class_level: number; subject: string }[]> {
        const faculty = await this.db.faculty.findFirst({
            where: { user_id: userId },
            include: { teaching_assignments: true },
        });

        if (!faculty) {
            return [];
        }

        return faculty.teaching_assignments.map((ta) => ({
            class_level: ta.class_level,
            subject: ta.subject,
        }));
    }

    /**
     * Find a user by phone number.
     * Used for authentication.
     * 
     * @param phone - User phone number
     * @returns User or null if not found
     */
    async findByPhone(phone: string): Promise<User | null> {
        return this.db.user.findUnique({ where: { phone } });
    }

    /**
     * Find a user by email.
     * Used for admin authentication.
     * 
     * @param email - User email
     * @returns User or null if not found
     */
    async findByEmail(email: string): Promise<User | null> {
        return this.db.user.findUnique({ where: { email } });
    }

    /**
     * Register a new user (self-registration from mobile app).
     * 
     * SECURITY NOTES:
     * - Only for non-admin roles
     * - User is created as inactive (requires admin approval)
     * - Password should already be hashed
     * 
     * @param data - Registration data
     * @param ipAddress - Client IP for logging
     * @returns Created user
     */
    async registerUser(data: RegisterUserData, ipAddress: string | null): Promise<User> {
        const user = await this.db.user.create({
            data: {
                name: data.name,
                email: data.email,
                password: data.password,
                phone: data.phone,
                role: data.role,
                gender: data.gender,
                profile_image_url: data.profile_image_url,
                is_active: data.is_active,
                device_id: null,
            },
        });

        return user;
    }

    /**
     * Update user's device_id.
     * Used when DELIVERY user logs in for the first time.
     * 
     * SECURITY: Once device_id is set, it cannot be changed.
     * 
     * @param userId - User ID
     * @param deviceId - Device ID to bind
     * @param ipAddress - IP address of the request
     */
    async bindDeviceId(
        userId: string,
        deviceId: string,
        ipAddress: string | null,
    ): Promise<User> {
        // Update device_id (only if not already set - checked in auth service)
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { device_id: deviceId },
        });

        // Log device binding
        await this.auditLogsService.log(
            AuditAction.DEVICE_ID_BOUND,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Reset user's device_id.
     * Used by admin to allow user to login from a new device.
     * 
     * @param userId - User ID
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async resetDeviceId(
        userId: string,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const user = await this.findById(userId);

        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { device_id: null },
        });

        await this.auditLogsService.log(
            AuditAction.USER_UPDATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Deactivate a user.
     * Prevents the user from logging in.
     * 
     * @param userId - User ID to deactivate
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async deactivate(
        userId: string,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { is_active: false },
        });

        await this.auditLogsService.log(
            AuditAction.USER_DEACTIVATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Toggle user active status.
     * Used by admin to activate or deactivate users.
     * 
     * @param userId - User ID to toggle
     * @param isActive - New active status
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async toggleActiveStatus(
        userId: string,
        isActive: boolean,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const user = await this.findById(userId);

        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { is_active: isActive },
        });

        await this.auditLogsService.log(
            isActive ? AuditAction.USER_ACTIVATED : AuditAction.USER_DEACTIVATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        // Send notification to user
        if (isActive) {
            await this.notificationsService.notifyAccountActivated(userId);
        } else {
            await this.notificationsService.notifyAccountDeactivated(userId);
        }

        return updatedUser;
    }

    /**
     * Update user's profile photo URL.
     * Used by admin CMS to update their profile photo.
     * 
     * @param userId - User ID
     * @param profileImageUrl - New profile image URL
     * @param ipAddress - IP address of the request
     */
    async updateProfilePhoto(
        userId: string,
        profileImageUrl: string,
        ipAddress: string | null,
    ): Promise<User> {
        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: { profile_image_url: profileImageUrl },
        });

        await this.auditLogsService.log(
            AuditAction.PROFILE_PHOTO_UPDATED,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Update personal details (name, phone, gender).
     * Used by mobile app users to update their basic info.
     * 
     * @param userId - User ID
     * @param data - Personal details to update
     * @param ipAddress - IP address of the request
     */
    async updatePersonalDetails(
        userId: string,
        data: { name?: string; phone?: string; gender?: Gender },
        ipAddress: string | null,
    ): Promise<User> {
        // Check if phone is being changed and if it's already taken
        if (data.phone) {
            const existingUser = await this.db.user.findUnique({
                where: { phone: data.phone },
            });
            if (existingUser && existingUser.id !== userId) {
                throw new ConflictException('Phone number already in use');
            }
        }

        const updatedUser = await this.db.user.update({
            where: { id: userId },
            data: {
                ...(data.name && { name: data.name }),
                ...(data.phone && { phone: data.phone }),
                ...(data.gender && { gender: data.gender }),
            },
        });

        await this.auditLogsService.log(
            AuditAction.USER_UPDATED,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Update approval status of a user's faculty record.
     * Admin only - approves or rejects faculty members.
     * 
     * @param userId - User ID whose faculty to update
     * @param status - APPROVED or REJECTED
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     * @param rejectionReason - Optional reason for rejection
     */
    async updateApprovalStatus(
        userId: string,
        status: 'APPROVED' | 'REJECTED',
        adminId: string,
        ipAddress: string | null,
        rejectionReason?: string,
    ): Promise<User> {
        // Find user with faculty
        const user = await this.db.user.findUnique({
            where: { id: userId },
            include: { faculty: true },
        });

        if (!user) {
            throw new NotFoundException('User not found');
        }

        if (!user.faculty) {
            throw new NotFoundException('User does not have a faculty profile');
        }

        // Update faculty approval status
        await this.db.faculty.update({
            where: { id: user.faculty.id },
            data: {
                approval_status: status,
                approved_by: adminId,
            },
        });

        // Log the action
        await this.auditLogsService.log(
            status === 'APPROVED'
                ? AuditAction.USER_APPROVED
                : AuditAction.USER_REJECTED,
            'Faculty',
            user.faculty.id,
            adminId,
            ipAddress,
        );

        // Send notification to user
        const notificationTitle = status === 'APPROVED'
            ? 'Profile Approved'
            : 'Profile Rejected';
        const notificationBody = status === 'APPROVED'
            ? 'Your profile has been approved. You now have full access to the app.'
            : `Your profile has been rejected.${rejectionReason ? ` Reason: ${rejectionReason}` : ''}`;

        await this.notificationsService.sendToUser({
            userId,
            title: notificationTitle,
            body: notificationBody,
            type: status === 'APPROVED' ? NotificationType.PROFILE_APPROVED : NotificationType.PROFILE_REJECTED,
        });

        // Return updated user
        return this.db.user.findUnique({
            where: { id: userId },
            include: {
                faculty: {
                    include: {
                        school: {
                            include: {
                                district: true,
                            },
                        },
                        teaching_assignments: true,
                    },
                },
            },
        }) as Promise<User>;
    }
}
