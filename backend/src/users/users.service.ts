import { Injectable, ConflictException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { AuditLogsService, AuditAction } from '../audit-logs/audit-logs.service';

/**
 * Users Service.
 * Handles all user-related business logic.
 * All sensitive operations are logged to audit_logs.
 */
@Injectable()
export class UsersService {
    constructor(
        @InjectRepository(User)
        private readonly userRepository: Repository<User>,
        private readonly auditLogsService: AuditLogsService,
    ) { }

    /**
     * Create a new user.
     * Phone must be unique across all users.
     * 
     * @param createUserDto - User creation data
     * @param creatorId - ID of the admin creating the user
     * @param ipAddress - IP address of the request
     * @returns Created user
     * @throws ConflictException if phone already exists
     */
    async create(
        createUserDto: CreateUserDto,
        creatorId: string,
        ipAddress: string | null,
    ): Promise<User> {
        // Check if phone already exists
        const existingUser = await this.userRepository.findOne({
            where: { phone: createUserDto.phone },
        });

        if (existingUser) {
            throw new ConflictException('User with this phone number already exists');
        }

        // Create user - created_at is auto-generated by TypeORM
        const user = this.userRepository.create({
            name: createUserDto.name,
            phone: createUserDto.phone,
            role: createUserDto.role,
            is_active: createUserDto.is_active ?? true,
            device_id: null, // Device ID is bound on first login
        });

        const savedUser = await this.userRepository.save(user);

        // Log to audit trail
        await this.auditLogsService.log(
            AuditAction.USER_CREATED,
            'User',
            savedUser.id,
            creatorId,
            ipAddress,
        );

        return savedUser;
    }

    /**
     * Find all users.
     * Used by admin to list all users.
     */
    async findAll(): Promise<User[]> {
        return this.userRepository.find({
            order: { created_at: 'DESC' },
        });
    }

    /**
     * Find a user by ID.
     * 
     * @param id - User UUID
     * @throws NotFoundException if user not found
     */
    async findById(id: string): Promise<User> {
        const user = await this.userRepository.findOne({ where: { id } });

        if (!user) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }

        return user;
    }

    /**
     * Find a user by phone number.
     * Used for authentication.
     * 
     * @param phone - User phone number
     * @returns User or null if not found
     */
    async findByPhone(phone: string): Promise<User | null> {
        return this.userRepository.findOne({ where: { phone } });
    }

    /**
     * Update user's device_id.
     * Used when DELIVERY user logs in for the first time.
     * 
     * SECURITY: Once device_id is set, it cannot be changed.
     * 
     * @param userId - User ID
     * @param deviceId - Device ID to bind
     * @param ipAddress - IP address of the request
     */
    async bindDeviceId(
        userId: string,
        deviceId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const user = await this.findById(userId);

        // Update device_id (only if not already set - checked in auth service)
        user.device_id = deviceId;
        const updatedUser = await this.userRepository.save(user);

        // Log device binding
        await this.auditLogsService.log(
            AuditAction.DEVICE_ID_BOUND,
            'User',
            userId,
            userId,
            ipAddress,
        );

        return updatedUser;
    }

    /**
     * Deactivate a user.
     * Prevents the user from logging in.
     * 
     * @param userId - User ID to deactivate
     * @param adminId - Admin performing the action
     * @param ipAddress - IP address of the request
     */
    async deactivate(
        userId: string,
        adminId: string,
        ipAddress: string | null,
    ): Promise<User> {
        const user = await this.findById(userId);
        user.is_active = false;
        const updatedUser = await this.userRepository.save(user);

        await this.auditLogsService.log(
            AuditAction.USER_DEACTIVATED,
            'User',
            userId,
            adminId,
            ipAddress,
        );

        return updatedUser;
    }
}
